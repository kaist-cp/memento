//! Linking Ralloc (https://github.com/urcs-sync/ralloc)

use etrace::some_or;

use super::{global_pool, PoolHandle};
use std::{
    mem::MaybeUninit,
    os::raw::{c_char, c_int, c_ulong, c_void},
};

/* automatically generated by rust-bindgen 0.59.1 */
//
// command: bindgen --allowlist-function "RP.*" ext/ralloc/src/ralloc.hpp -o ralloc.rs
#[link(name = "ralloc", kind = "static")]
extern "C" {
    /// If return is 1, the original file is opened, otherwise the file is newly created.
    pub(crate) fn RP_init(_id: *const c_char, size: u64) -> c_int;

    /// If the return is 1, it means that it is dirty, so it is garbage-collected, otherwise, it is not dirty, not garbage-collected.
    pub(crate) fn RP_recover() -> c_int;

    pub(crate) fn RP_close();

    pub(crate) fn RP_malloc(sz: c_ulong) -> *mut c_void;

    pub(crate) fn RP_free(ptr: *mut c_void);

    pub(crate) fn RP_set_root(ptr: *mut c_void, i: u64) -> *mut c_void;

    pub(crate) fn RP_get_root_c(i: u64) -> *mut c_void;

    #[allow(dead_code)]
    pub(crate) fn RP_malloc_size(ptr: *mut c_void) -> c_ulong;

    #[allow(dead_code)]
    pub(crate) fn RP_calloc(num: c_ulong, size: c_ulong) -> *mut c_void;

    #[allow(dead_code)]
    pub(crate) fn RP_realloc(ptr: *mut c_void, new_size: c_ulong) -> *mut c_void;

    #[allow(dead_code)]
    pub(crate) fn RP_in_prange(ptr: *mut c_void) -> c_int;

    #[allow(dead_code)]
    pub(crate) fn RP_region_range(
        idx: c_int,
        start_addr: *mut *mut c_void,
        end_addr: *mut *mut c_void,
    ) -> c_int;
}

/// Return the mapped address when RP_init
#[allow(non_snake_case)]
pub(crate) unsafe fn RP_mmapped_addr() -> usize {
    let mut start: *mut i32 = std::ptr::null_mut();
    let mut end: *mut i32 = std::ptr::null_mut();
    let _ret = RP_region_range(
        1, // superblock region's index.
        &mut start as *mut *mut _ as *mut *mut c_void,
        &mut end as *mut *mut _ as *mut *mut c_void,
    );
    start as usize
}

// Functions added for GC that are not in the original ralloc
#[link(name = "ralloc", kind = "static")]
extern "C" {
    /// Recognize Ralloc's type `GarbageCollection`
    pub type GarbageCollection;

    /// Register the root filter function, which is the starting point of GC.
    pub(crate) fn RP_set_root_filter(
        filter_func: ::std::option::Option<
            unsafe extern "C" fn(*mut c_char, usize, &mut GarbageCollection),
        >,
        i: u64,
    );

    #[link_name = "\u{1}_ZN17GarbageCollection11mark_func_cEPcmPFvS0_mRS_E"]
    pub(crate) fn RP_mark(
        this: *mut GarbageCollection,
        ptr: *mut c_char,
        tid: usize,
        filter_func: ::std::option::Option<
            unsafe extern "C" fn(*mut c_char, usize, &mut GarbageCollection),
        >,
    );
}

/// Trait for Garbage Collection
///
/// For a persistent obj to be marked by the Ralloc GC, it must impl this trait.
///
/// ```text
///             ----------- Black box ------------------      Ralloc
///            |                                        |
/// fn mark   --->          unsafe RP_mark             --->    ...
///     ^      |                                        |       |
///     |      |                                        |       |
///     |      |                                        |       v
/// fn filter <---       unsafe filter_inner           <---    ...
///            |                                        |
///             ----------------------------------------
/// ```
pub trait Collectable: Sized {
    /// Mark itself and reserve the next marking with its filter func
    fn mark(s: &mut Self, tid: usize, gc: &mut GarbageCollection) {
        let ptr = s as *mut _ as *mut c_char;
        unsafe { RP_mark(gc, ptr, tid, Some(Self::filter_inner)) };
    }

    /// - This function is intended to be called by Ralloc and should not be used by the user.
    /// - When Ralloc calls this function, Rust finds obj's filter func and calls it
    ///
    /// # Guaranteed by Ralloc
    ///
    /// - The ptr passed by Ralloc is a raw pointer pointing to itself.
    ///
    /// # Safety
    ///
    /// Do not use this function
    unsafe extern "C" fn filter_inner(ptr: *mut c_char, tid: usize, gc: &mut GarbageCollection) {
        let pool = global_pool().unwrap();
        let s = (ptr as *mut _ as *mut Self).as_mut().unwrap();
        Self::filter(s, tid, gc, pool);
    }

    /// Find something to mark in its field and mark it
    ///
    /// # Example
    ///
    /// ```
    /// # use memento::pmem::pool::PoolHandle;
    /// # use memento::pmem::ralloc::GarbageCollection;
    /// # use memento::pmem::ralloc::Collectable;
    /// # use memento::pmem::ptr::PPtr;
    /// # struct Inner {}
    /// # impl Collectable for Inner {
    /// #    fn filter(_: &mut Self, _: &mut GarbageCollection, _: &PoolHandle) {
    /// #    }
    /// # }
    /// struct Node {
    ///     inner: Inner, // Assume `Inner` impl Collectable
    ///     next: PPtr<Node>,
    /// }
    ///
    /// impl Collectable for Node {
    ///     fn filter(node: &mut Self, gc: &mut GarbageCollection, pool: &PoolHandle) {
    ///         // Call filter of inner to mark the ptr in the inner struct
    ///         Inner::filter(&mut node.inner, gc, pool);
    ///
    ///         // Mark the next node if the pointer is valid
    ///         if !node.next.is_null() {
    ///             let next = unsafe { node.next.deref_mut(pool) };
    ///             Node::mark(next, gc);
    ///         }
    ///     }
    /// }
    /// ```
    fn filter(s: &mut Self, tid: usize, gc: &mut GarbageCollection, pool: &mut PoolHandle);
}

impl<T: Collectable, U: Collectable, Z: Collectable> Collectable for (T, U, Z) {
    fn filter(s: &mut Self, tid: usize, gc: &mut GarbageCollection, pool: &mut PoolHandle) {
        T::filter(&mut s.0, tid, gc, pool);
        U::filter(&mut s.1, tid, gc, pool);
        Z::filter(&mut s.2, tid, gc, pool);
    }
}

impl<T: Collectable, U: Collectable> Collectable for (T, U) {
    fn filter(s: &mut Self, tid: usize, gc: &mut GarbageCollection, pool: &mut PoolHandle) {
        T::filter(&mut s.0, tid, gc, pool);
        U::filter(&mut s.1, tid, gc, pool);
    }
}

impl Collectable for () {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for usize {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for u64 {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for u32 {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for u8 {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for bool {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl Collectable for c_void {
    fn filter(_: &mut Self, _: usize, _: &mut GarbageCollection, _: &mut PoolHandle) {}
}

impl<T: Collectable> Collectable for Option<T> {
    fn filter(opt: &mut Self, tid: usize, gc: &mut GarbageCollection, pool: &mut PoolHandle) {
        let v = some_or!(opt, return);
        T::filter(v, tid, gc, pool);
    }
}

impl<T: Collectable> Collectable for MaybeUninit<T> {
    fn filter(mu: &mut Self, tid: usize, gc: &mut GarbageCollection, pool: &mut PoolHandle) {
        T::filter(unsafe { mu.assume_init_mut() }, tid, gc, pool);
    }
}

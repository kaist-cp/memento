#![allow(non_camel_case_types)]
#![allow(missing_docs)]

pub type size_t = ::std::os::raw::c_ulong;
pub type __uint64_t = ::std::os::raw::c_ulong;

/* automatically generated by rust-bindgen 0.59.1 */
//
// command: bindgen --allowlist-function "RP.*" ralloc/src/ralloc.hpp -o ralloc.rs
//
// 원래 ralloc에 있던 함수
#[link(name = "ralloc", kind = "static")]
extern "C" {
    /// return이 1이면 원래 존재하는 파일을 open한 것, 0이면 파일 새로 만든 것
    pub fn RP_init(_id: *const ::std::os::raw::c_char, size: u64) -> ::std::os::raw::c_int;

    /// return이 1이면 dirty라서 gc 돌린 것, 0이면 dirty 아니라서 gc 안돌린 것
    pub fn RP_recover() -> ::std::os::raw::c_int;

    pub fn RP_close();

    pub fn RP_malloc(sz: size_t) -> *mut ::std::os::raw::c_void;

    pub fn RP_free(ptr: *mut ::std::os::raw::c_void);

    pub fn RP_set_root(ptr: *mut ::std::os::raw::c_void, i: u64) -> *mut ::std::os::raw::c_void;

    pub fn RP_get_root_c(i: u64) -> *mut ::std::os::raw::c_void;

    pub fn RP_malloc_size(ptr: *mut ::std::os::raw::c_void) -> size_t;

    pub fn RP_calloc(num: size_t, size: size_t) -> *mut ::std::os::raw::c_void;

    pub fn RP_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: size_t,
    ) -> *mut ::std::os::raw::c_void;

    pub fn RP_in_prange(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;

    pub fn RP_region_range(
        idx: ::std::os::raw::c_int,
        start_addr: *mut *mut ::std::os::raw::c_void,
        end_addr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}

// 원래 ralloc에는 없고 GC를 위해 추가한 함수
#[link(name = "ralloc", kind = "static")]
extern "C" {
    // Ralloc의 type `GarbageCollection`을 인식
    pub type GarbageCollection;

    pub fn RP_set_root_mark(
        mark: ::std::option::Option<
        unsafe extern "C" fn(*mut ::std::os::raw::c_char, *mut GarbageCollection),
        >,
        i: u64,
    );

    #[link_name = "\u{1}_ZN17GarbageCollection11mark_func_cEPcPFvS0_RS_E"]
    pub fn GarbageCollection_mark_func_c(
        this: *mut GarbageCollection,
        ptr: *mut ::std::os::raw::c_char,
        filter_func: ::std::option::Option<
            unsafe extern "C" fn(*mut ::std::os::raw::c_char, *mut GarbageCollection),
        >,
    );
}

/// Trait for Garbage Collection
// TODO: impl 안해도 filter 함수를 볼 수 있는 게 불편함
pub trait Collectable {
    /// ptr이 가리키는 주소를 marking하고, filter func으로 다음 marking을 수행
    ///
    /// # Safety
    ///
    /// * ptr은 자신을 가리키는 raw 포인터여야함
    // C에서 이 함수의 이름이 아닌 주소로 호출하므로 #[no_mangle] 필요없어보임
    unsafe extern "C" fn mark(ptr: *mut ::std::os::raw::c_char, gc: *mut GarbageCollection) {
        GarbageCollection_mark_func_c(gc, ptr, Some(Self::filter));
    }

    /// ptr이 가리키는 obj의 필드 중 다음 marking 할 것을 찾아서 marking
    ///
    /// # Safety
    ///
    /// * 이 함수는 Ralloc에서 호출되게 할 용도로, 유저는 정의만 할 뿐 직접 사용하면 안됨
    /// * Ralloc에서 넘겨주는 ptr은 자신을 가리키는 raw 포인터를 가리킴 (detail: mark로 넣어준 ptr이, 이 filter의 ptr로 들어옴)
    ///
    /// # Example
    ///
    /// ```no_run
    /// struct Node {
    ///     val: usize,
    ///     next: PPtr<Node>,
    /// }
    ///
    /// impl Collectable for Node {
    ///     extern "C" fn filter(ptr: *mut std::os::raw::c_char, gc: *mut GarbageCollection) {
    ///         let node = (ptr as *mut Self).as_ref().unwrap();
    ///         let next = node.next;
    ///         // ... get absolute address of next node => `addr_next`
    ///         Node::mark(addr_next, gc);
    ///     }
    /// }
    /// ```
    // C에서 이 함수의 이름이 아닌 주소로 호출하므로 #[no_mangle] 필요없어보임
    unsafe extern "C" fn filter(ptr: *mut ::std::os::raw::c_char, gc: *mut GarbageCollection);
}

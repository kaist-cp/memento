#![allow(non_camel_case_types)]
#![allow(missing_docs)]

pub type size_t = ::std::os::raw::c_ulong;
pub type __uint64_t = ::std::os::raw::c_ulong;

/* automatically generated by rust-bindgen 0.59.1 */
//
// command: bindgen --allowlist-function "RP.*" ralloc/src/ralloc.hpp -o ralloc.rs
//
// 원래 ralloc에 있던 함수
#[link(name = "ralloc", kind = "static")]
extern "C" {
    /// return이 1이면 원래 존재하는 파일을 open한 것, 0이면 파일 새로 만든 것
    pub fn RP_init(_id: *const ::std::os::raw::c_char, size: u64) -> ::std::os::raw::c_int;

    /// return이 1이면 dirty라서 gc 돌린 것, 0이면 dirty 아니라서 gc 안돌린 것
    pub fn RP_recover() -> ::std::os::raw::c_int;

    pub fn RP_close();

    pub fn RP_malloc(sz: size_t) -> *mut ::std::os::raw::c_void;

    pub fn RP_free(ptr: *mut ::std::os::raw::c_void);

    pub fn RP_set_root(ptr: *mut ::std::os::raw::c_void, i: u64) -> *mut ::std::os::raw::c_void;

    pub fn RP_get_root_c(i: u64) -> *mut ::std::os::raw::c_void;

    pub fn RP_malloc_size(ptr: *mut ::std::os::raw::c_void) -> size_t;

    pub fn RP_calloc(num: size_t, size: size_t) -> *mut ::std::os::raw::c_void;

    pub fn RP_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: size_t,
    ) -> *mut ::std::os::raw::c_void;

    pub fn RP_in_prange(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;

    pub fn RP_region_range(
        idx: ::std::os::raw::c_int,
        start_addr: *mut *mut ::std::os::raw::c_void,
        end_addr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}

// 원래 ralloc에는 없고 GC를 위해 추가한 함수
#[link(name = "ralloc", kind = "static")]
extern "C" {
    // Ralloc의 type `GarbageCollection`을 인식
    pub type GarbageCollection;

    pub fn RP_set_root_mark(
        mark: ::std::option::Option<
        unsafe extern "C" fn(*mut ::std::os::raw::c_char, *mut GarbageCollection),
        >,
        i: u64,
    );

    #[link_name = "\u{1}_ZN17GarbageCollection11mark_func_cEPcPFvS0_RS_E"]
    pub fn GarbageCollection_mark_func_c(
        this: *mut GarbageCollection,
        ptr: *mut ::std::os::raw::c_char,
        filter_func: ::std::option::Option<
            unsafe extern "C" fn(*mut ::std::os::raw::c_char, *mut GarbageCollection),
        >,
    );
}

/// Trait for Garbage Collection
// TODO: impl 안해도 filter 함수를 볼 수 있는 게 불편함
pub trait Collectable {
    /// ptr이 가리키는 주소를 marking하고, filter func으로 다음 marking을 수행
    ///
    /// # Safety
    ///
    /// * ptr은 자신을 가리키는 raw 포인터여야함
    // C에서 이 함수의 이름이 아닌 주소로 호출하므로 #[no_mangle] 필요없어보임
    unsafe extern "C" fn mark(ptr: *mut ::std::os::raw::c_char, gc: *mut GarbageCollection) {
        GarbageCollection_mark_func_c(gc, ptr, Some(Self::filter));
    }

    /// ptr이 가리키는 obj의 필드 중 다음 marking 할 것을 찾아서 marking
    ///
    /// # Safety
    ///
    /// * 이 함수는 Ralloc에서 호출되게 할 용도로, 유저는 정의만 할 뿐 직접 사용하면 안됨
    /// * Ralloc에서 넘겨주는 ptr은 자신을 가리키는 raw 포인터를 가리킴 (detail: mark로 넣어준 ptr이, 이 filter의 ptr로 들어옴)
    ///
    /// # Example
    ///
    /// ```no_run
    /// struct Node {
    ///     val: usize,
    ///     next: PPtr<Node>,
    /// }
    ///
    /// impl Collectable for Node {
    ///     extern "C" fn filter(ptr: *mut std::os::raw::c_char, gc: *mut GarbageCollection) {
    ///         let node = (ptr as *mut Self).as_ref().unwrap();
    ///         let next = node.next;
    ///         // ... get absolute address of next node => `addr_next`
    ///         Node::mark(addr_next, gc);
    ///     }
    /// }
    /// ```
    // C에서 이 함수의 이름이 아닌 주소로 호출하므로 #[no_mangle] 필요없어보임
    unsafe extern "C" fn filter(ptr: *mut ::std::os::raw::c_char, gc: *mut GarbageCollection);
}

#[cfg(test)]
mod tests{
    use std::sync::atomic::Ordering;
    use crate::{pepoch::{self, PAtomic}, persistent::POp, plocation::{Pool, PoolHandle, global_pool, ralloc::*}, utils::tests::get_test_abs_path};
    #[derive(Debug)]
    struct Node {
        traced: bool,
    }
    impl Collectable for Node {
        unsafe extern "C" fn filter(ptr: *mut std::os::raw::c_char, _: *mut GarbageCollection) {
            println!("call node filter");
            let node = (ptr as *mut Self).as_mut().unwrap();
            node.traced = true;

            // no more ptr to trace
        }
    }

    #[derive(Debug, Default)]
    struct RootOp {
        node1: PAtomic<Node>,
        node2: PAtomic<Node>,
        initialized: bool,
    }
    impl Collectable for RootOp {
        unsafe extern "C" fn filter(ptr: *mut std::os::raw::c_char, gc: *mut GarbageCollection) {
            let pool = global_pool().unwrap();
            let guard = pepoch::unprotected(pool);

            // Get Self
            let root = (ptr as *mut Self).as_ref().unwrap();

            // Get absolute addr of node1, 2
            let node1_raw = root.node1.load(Ordering::SeqCst, guard).deref_mut(pool) as *mut _ as *mut std::os::raw::c_char;
            let node2_raw = root.node2.load(Ordering::SeqCst, guard).deref_mut(pool) as *mut _ as *mut std::os::raw::c_char;

            // Mark nodes to trace
            Node::mark(node1_raw, gc);
            Node::mark(node2_raw, gc);
        }
    }

    impl POp for RootOp {
        type Object<'o> = ();
        type Input = ();
        type Output<'o> = ();
        type Error = !;

        fn run<'o>(
        &mut self,
        _: Self::Object<'o>,
        _: Self::Input,
        pool: &PoolHandle,
    ) -> Result<Self::Output<'o>, Self::Error> {
            if !self.initialized {
                self.node1 = PAtomic::new(Node { traced: false}, pool);
                self.node2 = PAtomic::new(Node { traced: false}, pool);
                self.initialized = true;
            }
            Ok(())
        }

        fn reset(&mut self, _: bool) {
            // no-op
        }
    }

    const FILE_NAME: &str = "gc.pool";
    const FILE_SIZE: usize = 8 * 1024 * 1024 * 1024;

    // gc가 root에 딸린 포인터들을 잘 trace하는지 테스트
    // - 현재는 이 테스트를 2번 실행했을 때 출력문으로 3개 block이(root, root.node1, root.node2) 잘 trace됨을 확인가능
    // - TODO: 자동화
    #[test]
    fn gc() {
        let filepath = get_test_abs_path(FILE_NAME);

        // 풀 열기 (없으면 새로 만듦)
        let pool_handle = unsafe { Pool::open::<RootOp>(&filepath, FILE_SIZE) }
            .unwrap_or_else(|_| Pool::create::<RootOp>(&filepath, FILE_SIZE).unwrap());

        // 루트 Op 가져오기
        let root_op = pool_handle.get_root::<RootOp>();

        // 루트 Op 실행. 이 경우 루트 Op은 invariant 검사(flag=1 => value=42)
        root_op.run((), (), &pool_handle).unwrap();
    }
}
